## 异步I/O

### 为何要异步 I/O

#### 1. 用户体验

浏览器中的 JavaScript 在单线程上执行，并且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应处于停滞状态。前端通过异步可以消除 UI 阻塞的现象。但是前端获取资源的速度也取决于后端的响应速度。

异步I/O在Node中如此盛行，因为I/O是昂贵的，分布式I/O是更昂贵的。

#### 2. 资源分享

计算机在发展过程中将组建进行了抽象，分为I/O设备和计算设备。

假设业务场景中有一组互不相关的任务需要完成，现在主流方法有以下两种。

* 单线程串行依次执行
* 多线程并行执行

如果创建多线程的开销小于并行执行，那么多线程的方式是首选。多线程的代价在于创建线程或执行期线程上下文切换的开销较大。

在复杂的业务中，多线程经常面临锁、状态同步等问题，这是多线程被诟病的主要原因。

单线程的确定在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。

单线程同步编程模型会因为阻塞 I/O 导致硬件资源得不到更优的使用，多线程编程模型也因为编程中的死锁、状态同步等问题让开发人员头疼。

Node 在这两者之间给出的方案是: 利用单线程，远离多线程死锁、状态同步等问题；利用异步 I/O 让单线程远离阻塞，更好利用 CPU。

为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效地利用 CPU 和 I/O。

异步 I/O 的提出是期望 I/O 的调用不再阻塞后续运算，将原有等待 I/O 完成的这段时间分配给其他需要的业务去执行。

### 异步 I/O 实现现状

#### 1. 异步I/O与非阻塞I/O

* 阻塞I/O造成CPU等待I/O，浪费等待时间，CPU处理能力不能得到充分利用。
* 非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务。性能提升很明显

但非阻塞I/O也存在一些缺点，为获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成，这种重复调用判断操作是否完成的技术叫轮询。


阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完成数据读取，它会让CPU处理状态判断，是对CPU资源的浪费。

#### 轮询技术

* read。最原始、性能最低的一种。通过重复调用来检查I/O的状态来完成完整数据的读取，在得到最终数据前，CPU 一直耗在等待上。
* select。是在read的基础上改进的方案，通过对文件描述符上的事件状态进行判断。select 轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述
* poll。是对select的改变，利用链表的方法避免数组长度的限制，其次避免不必要的检查。
* epoll。是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，CPU将会进行休眠。利用事件通知，执行回调的方式，而不是遍历查询，不会浪费CPU，执行效率高。


轮询技术满足了非阻塞I/O确保获取完整数据的需求。但对于应用程序而已，它仍然只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间来等待。等待期间，CPU要么用于遍历文件描述的状态，要么用于休眠等待事件发生。

#### 2. 理想的非阻塞异步I/O

期望的完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成通过信号后或回调将数据传递给应用程序即可。

#### 3.现实的异步I/O

现实比理想要骨感一些，但是要达成异步 I/O 的目标，并非难事。前面我们将场景限定在单线程的状况下，多线程的方式会是另一番风景。通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，实现异步 I/O。

我们时常提到 Node 是单线程的，这里的单线程仅仅只是 JavaScript 执行在单线程中罢了，在 Node 中，无论是 *nix 还是 windows 平台，内部完成 I/O 认识的另有线程池。

### Node 的异步 I/O

#### 1. 事件循环

Node 自身的执行模式--事件循环，正是它使得回调函数十分普遍。

在进程启动时，Node 便会创建一个类似于while的循环，每执行一次循环体的过程我们成为 Tick，每个Tick的过程就是查看是否有事件待处理。

#### 2. 观察者

每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。

事件循环是一个典型的生产者/消费者模型。

#### 3. 请求对象

对Node而言，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫请求对象。

从JavaScript调用Node的核心模块，核心模板调用C++内建模块，内建模块通过libuv进行系统调用，这是Node里经典的调用方式。

请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。

#### 4.执行回调

I/O 观察者回调函数的行为是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。

整个异步I/O的流程见图3-13。

* 异步调用

开始 --> 发起异步调用 --> 封装请求对象 --> 设置参数和回调函数 --> 将请求对象放入线程池等待执行 --> 结束

* 线程池

开始 --> 线程可用 --> 执行请求对象中的I/O操作 --> 将执行完成的结果放在请求对象中 --> 通知IOCP调用完成 --> 归还线程 --> 结束

* 事件循环

开始 --> 创建主循环 --> 从I/O观察者取到可用的请求对象 --> 取出回调函数和结果调用执行 --> 获取完成的I/O交给I/O观察者

事件循环、观察者、请求对象、I/O线程池这四者共同构成了Noe异步I/O模型的基本要求。

在Node中除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。另外除了用户代码无法并行执行外，所有的I/O是可以并行的。

### 非 I/O 的异步 API

#### 1. 定时器

* setTimeout()
* setInterval()

定时器的问题在于，它并非精确的。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时许久。

#### 2. process.nextTick()

由于事件循环自身的特定，定时器的精度不够。而事实上，定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, o)的方式较为浪费性能。

每次调用 process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。时间复杂度为O(1)

```
setImmediate(function () {
    console.log('setImmediate 延迟执行!');
});

process.nextTick(function () {
    console.log('nextTick 延迟执行!');
});

console.log('正常执行!');

// 输出
正常执行!
nextTick 延迟执行!
setImmediate 延迟执行!
```
process.nextTick() 中的回调函数优先级高于 setImmediate()。原因在于事件对观察者的检查具有先后顺序，process.nextTick() 属于 idle 观察者， setImmediate() 属于 check 观察者，在每一轮循环检查中，idle 观察者先于 I/O 观察者，I/O 观察者先于 check 观察者。

 process.nextTick() 的回调函数保存在一个数组中，setImmediate() 的结果保存在链表中，在行为上，process.nextTick() 在每轮循环中会将数组中的回调函数全部执行完，而 setImmediate() 在每轮循环中执行链表中的一个回调函数。
 
```
setImmediate(function () {
    console.log('setImmediate 延迟执行1');

    process.nextTick(function () {
        console.log('强势插入 nextTick');
    });
});

setImmediate(function () {
    console.log('setImmediate 延迟执行2');
});

process.nextTick(function () {
    console.log('nextTick 延迟执行1');

    process.nextTick(function () {
        console.log('强势插入 setImmediate');
    });

});

process.nextTick(function () {
    console.log('nextTick 延迟执行2');
});

console.log('正常执行');

// 输出
正常执行
nextTick 延迟执行1
nextTick 延迟执行2
强势插入 setImmediate
setImmediate 延迟执行1
setImmediate 延迟执行2
强势插入 nextTick
```
### 事件驱动与高性能服务器

异步实现的原理：通过主循环加事件触发的方式来运行程序。

利用 Node 构建 Web 服务器的流程图 如图 3-15.

经典的服务器模型

* 同步式。 一次只能处理一个请求，其余请求处于等待
* 每进程/每请求。为每个请求启动一个进程，可以处理多个请求，但不具备扩展性
* 每线程/每请求。为每个请求启动一个线程来处理

Node 通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价更低。即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是 Node 高性能的一个原因。
