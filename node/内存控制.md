## 内存控制

### V8的垃圾回收机制与内存限制

#### 1. Node 与 V8

Node 创始人选择了 V8 来作为 Node 的 JavaScript 脚步引擎。

V8 是JavaScript的脚步引擎。

Node 在 JavaScritp 的执行上直接受益于 V8，可以随着 V8 的升级能享受到更好的性能或新的语言特性，同时也受到 V8 的一些限制。

#### 2. V8 的内存限制

在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存。64位系统下约为 1.4GB，32位系统下约为0.7GB。

造成这个问题的主要原因是在 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上同时通过 V8 自己的方式进行分配管理的。V8 这套内存管理机制在浏览器的应用场景下使用是绰绰有余的，足以胜任前端页面中所有需求。但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。

#### 3. V8的对象分配

在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的。查看内存使用量的方式。

```
> process.memoryUsage()
{ rss: 19787776, heapTotal: 10771712, heapUsed: 5128704 }
```

heapTotal 和 heapUsed 是 V8 的堆内存使用情况。

* heapTotal: 已经申请到的堆内存
* heapUsed: 当前使用的量

当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止。

V8 的垃圾回收机制：按照官方的说法，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至需要 1 秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间，这样的时间开销下，应用的性能和响应时间都会直线下降。

V8 提供了选项可以让我们使用更多的内存，Node 在启动时传递 --max-old-space-size 或 --max-new-space-size 来调整内存限制的大小。

```
node --max-old-space-size=1700 test.js // 单位是MB
node --max-new-space-size=1700 test.js // 单位是KB
```
上述参数在V8初始化时生效，一旦生效就不能在动态改变。

#### 4. V8 的垃圾回收机制

V8 的垃圾回收策略主要基于分代式垃圾回收机制。没有任何一种垃圾回收算法能胜任所有的场景。

现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。

**V8 的内存分代**

在 V8 中，主要将内存分为新生代和老生代两代，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。--max-old-space-size 命令行参数可以设置老生代内存空间的最大值，--max-new-space-size 命令行参数则用于设置新生代内存空间的大小。

* 老生代内存在 64 位系统下为 1400MB，在 32 位系统下为 700 MB
* 新生代内存在 64 位系统下为 32MB，在32 位系统下为 16MB

V8 堆内存的最大值在 64 位系统上为 1464MB，在32位系统上为 732MB

**Scavenge算法**

在分代的基础上，新生代中的对象主要通过 Scavenge 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用 Cheney 算法。

Cheney 算法是一种采用复制的方式实现的垃圾回收算法，它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用状态，另一个处于空置状态。处于使用状态的 semispace 空间被称为 From 空间，处于闲置状态的空间称为 To 空间。

分配对象时，先是在 From 空间进行分配，当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生兑换。

Scavenge 的缺点是只能使用堆内存的一半，但由于 Scavenge 只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以在时间效率上有优异的表现。

Scavenge 是典型的牺牲空间换取时间的算法。非常适合应用新生代中，因为新生代中对象的生命周期较短。

当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长的生命周期的对象随后会被移动到老生代中。对象从新生代中移动到老生代中的过程称为晋升。

对象晋升的条件主要有两个，一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过限制。

**Mark-Sweep & Mark-Compact**

对于老生代中的对象，由于存活对象占比较大比重。无法采用 Scavenge 算法，主要采用 Mark-Sweep 和 Mark-Compact 相结合的方式进行垃圾回收。

Mark-Sweep 是标记清楚的意思，它分为标记和清初两个阶段。Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。

Mark-Sweep 最大的问题是在进行一次标记清除后，内存空间会出现不连续的状态，这种内存碎片对后续的内存分配影响很大。

为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 被提出。Mark-Compact 是标记整理的意思，是在 Mark-Sweep 的基础上演变而来。主要差别在于对象被标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

| 回收算法 		| Mark-Sweep | Mark-Compact| Scavenge   |
| ---------- |:----------:| :-----------:|:---------:|
| 速度    		| 中等 			| 最慢        |最快         |
| 空间开销    | 少(有碎片)   | 少(有碎片)   |双倍空间(无碎片)|
| 是否移动对象 | 否          | 是   		|     是       |

**Incremental Marking**

为了避免出现 JavaScript 应用逻辑与垃圾回收器看到不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后在恢复执行应用逻辑，这种行为被称为 "全停顿"。

为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，也就是拆分为许多小 "步进"，每完成一 "步进" 就让 JavaScript 应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记完成阶段。


#### 5. 查看垃圾回收日志

查看垃圾回收日志的方式主要是在启动时添加 --trace_gc 参数。在进行垃圾回收时，将会从标准输出中打印垃圾回收的日志信息。

通过在 Node 启动时使用 --prof 参数，可以得到 V8 执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间。

V8 提供了 linux-tick-processor 工具用于统计日志信息。

### 高效使用内存

如果在非全局作用域中，想主动释放变量引用的对象，可以通过 delete 和重新赋值的方式。虽然 delete 操作和重新赋值具有相同的结果，但是在 V8 中通过 delete 删除对象的属性有可能干扰 V8 的优化，所以通过赋值方式解除引用更好。

#### 闭包

实现外部作用域访问内部作用域中变量的方法叫闭包。

```
var bar = function () {
	var local = "局部变量";
	return function () {
		return local;
	};
};

var baz = bar();
console.log(baz);
```
一般而言，在 bar() 函数执行完成后，局部变量local将会随着作用域的销毁而被回收，但是注意这里的特点在于返回值是一个匿名函数，且这个函数中具备访问local的条件。虽然在后续的执行中，在外部作用域中还是无法直接访问 local，但是若要访问它，只能通过这个中间函数稍作周旋即可。

### 内存指标

#### 1. 查看进程的内存占用

```
> process.memoryUsage()
{ rss: 19312640, heapTotal: 10771712, heapUsed: 4756040 }
```

* rss 是 resident set size 的缩写，即进程的常驻内存部分
* heapTotal 是堆中总共申请的内存量
* heapUsed 是目前堆中使用的内存量

这三个值得单位都是字节。

#### 2. 查看系统的内存占用

os 模块中的 totalmem() 和 freemem() 这两个方法用于查看操作系统内存使用情况。

```
// 系统的总内存
> os.totalmem()
8589934592

// 系统的闲置内存
> os.freemem()
32190464
```

#### 4. 堆外内存

通过 process.memoryUsage() 可以看出，堆中的内存用量总是小于进程的常驻内存用量，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的。

我们将那些不是通过 V8 分配的内存称为堆外内存。 堆外内存可以突破内存限制的问题。

#### 5. 小结

从上面可以得知，Node 的内存构成主要由通过 V8 进行分配的部门和 Node 自行分配的部分。受 V8 的垃圾回收限制主要是 V8 的堆内存。

### 内存泄漏

内存泄漏的实质只有一个，就是应当回收的对象出现意外的没有被回收，变成了常驻在老生代中的对象。

造成内存泄漏的原因如下。

* 缓存
* 队列消费不及时
* 作用域未释放

#### 1. 慎将内存当做缓存

在 Node 中，一旦一个对象被当做缓存来使用，它将会常驻在老生代中，缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收进行扫描和整理时，对这些对象做无用功。

另外一个问题在于，JavaScript 开发者通常喜欢用对象的键值对来缓存对象，但这与严格意义上缓存有着区别，严格意义的缓存有着完善的过期策略，而普通对应的键值对并没有。

在Node中，任何试图拿内存当缓存的行为都应当被限制。

**缓存限制策略**

为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。

**缓存的解决方案**

如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部缓存有着良好的过期淘汰策略以及自有的内存管理。

* 将缓存转移到外部，减少常驻内存的对象数量，让垃圾回收更高效
* 进程之间可以共享缓存

#### 2. 关注队列状态

在解决缓存带来的内存泄漏问题后，另一个不经意产生的内存泄漏则是队列。

遇到这种场景，表层的解决方案是换用消费速度更高的技术。

深度解决方案应该监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。

### 内存泄漏排查

一些常用的工具。

* V8-profile: 用于对 V8 堆内存抓取快照和对CPU进行分析，该项目3年没有人维护了
* node-heapdump: 允许对 V8 堆内存抓取快照，用于事后分析
* node-mtrace: 使用GCC的mtrace工具来分析堆的使用
* dtrace: 在SmartOS系统上，有完善的dtrace工具来分析内存泄漏
* node-memmwatch: 采用WTFPL许可发布

#### 1. node-heapdump

#### 2.node-memwatch


### 大内存应用

在 Node 中，不可避免地还是会存在操作大文件的场景，由于Node的内存限制，操作大文件需要特别小心，好在 Node 提供了 stream 模块用于处理大文件。

stream 模块是 Node 的原声模块，直接引用即可。stream 继承自 EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。

如果不需要进行字符串层面的操作，则不需要借助 V8 来处理，可以尝试纯粹的 Buffer 操作，这不会受到 V8 堆内存的限制。但是这种大片使用内存的情况依然要小心，即使 V8 不限制堆内存的大小，物理内存依然有所限制。

### 小结

Node 将 JavaScript 的主要应用场景扩展到了服务器端，相应要考虑的细节与浏览器端不同，需要更为有严谨的为每一份资源做出安排。

### 参考文章

[如何自己检查NodeJS的代码是否存在内存泄漏](http://www.w3ctech.com/topic/842)