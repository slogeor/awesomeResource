## 构建 Web 应用

由于前后端采用的语言是 JavaScript，在跨越 HTTP 进行沟通时，会有一些额外的好处。

* 无须切换语言环境，部分知识不会因为语言环境切换而丢失，上下文一致性较好
* 数据可以很好地实现跨前后端直接使用
* 一些业务可以很自由地轻量的选择是在前端还是后端进行，因为编程语言相同，切换代价小

### 基本功能

#### 1. 请求方法

HTTP_Parser 在解析请求报文的时候，将报文头抽取出来，设置为 req.method。

#### 2. 路径解析

HTTP_Parser 将其解析为 req.url。

#### 3. 查询字符串

这部分内容精彩需要我业务逻辑所用，Node 提供了 querystring 模块用于处理这部分数据。

```
var  url = require(''url');
var querystring = require('querystring);
var query = querystring.parse(url.parse(req.url).query);

// 传递第二个参数也可以实现
var query = url.parse(req.url, true).query;
```

如果查询字符串中的键出现多次，那么它的值会是一个数组。

#### 4. cookie

Cookie 是一个由浏览器和服务器共同协作实现的规范，Cookie 的处理过程如下。

* 服务器向客户端发送 Cookie
* 浏览器将 Cookie 保持
* 之后每次浏览器都会将 Cookie 发向服务器

**设置 Cookie**

告知客户端的方式是通过响应报文实现的，响应的 Cookie 值在 Set-Cookie 字段中，它的格式与请求中的格式不大相同，规范中对它定义如下。

Set-Cookie: name=value; path=/ Expires=Mon Sep 19 2016 07:13:30 GMT+0800 (CST); Domain=.domain.com

* path: Cookie 的影响路径，当前路径不满足该匹配时，浏览器不会发送这个 Cookie
* Expires 和 Max-Age: 告知浏览器这个 Cookie 的过期时间。如果不设置该选项，关闭浏览器时会丢失这个 Cookie。设置了过期时间，浏览器会将 Cookie 内容写到磁盘中并保存。
* HttpOnly: 告知浏览器不允许通过脚本 document.cookie 去更改这个值，但是在 Http 请求的过程中，依然会发送这个 Cookie 到服务器端
* Secure: 当 Secure 为 true 时，在 HTTP 中是无效的，在 HTTPS 中才有效。表示创建的 Cookie 只能在 HTTPS 连接中被浏览器传递到服务器端进行会话

**Cookie的性能**

* 减少 Cookie 的大小: Cookie 会导致报文头变大
* 为静态组件使用不同的域名
* 减少 DNS 查询

#### 5. Session

Cookie 对于敏感数据的保护是无效的。 为了解决 Cookie 敏感数据的问题，Session 应运而生。Session 的数据只保留在服务器端，客户端无法进行修改。数据也无须在协议中每次都被传递。

如何将每个客户和服务器中的数据一一对应起来。

**第一种：基于 Cookie 来实现用户和数据的映射**

可以将口令放在 Cookie 中，因为口令一旦被篡改，就丢失映射关系，也无法修改服务器端存在的数据，Session 的有效期通常很短，普遍设置 20 分钟。

**第二种：通过查询字符串来实现浏览器端和服务器端数据的对应**

原理是检查请求的查询字符串，如果没有值，会先生成新的带值的URL。

如果用户访问 http://localhost/pathname 时，如果服务器发现查询字符串中不带 session_id 参数，就会将用户跳转到 http://localhost/pathname?session_id=123456 这样一个类似的地址。

这种方案无须在响应时设置 Cookie，但是这种方案存在风险远大于基于 Cookie 实现的方案，因为只需要将地址栏中的地方发送给别人，那么他就拥有你的身份了。

**Session 与内存**

Session 数据直接存在变量 session 中，位于内存中。将数据存放在内存中将会带来极大的隐患，如果用户增多，可能会接触到内存限制的上限，并且内存中的数据量加大，必然会引起垃圾回收的频率扫描，引起性能问题。

Node 的进程与进程之间是不能直接共享内存的，用户的 Session 会引起错乱。

为了解决性能问题和 Session 数据无法跨越进程共享的问题，常用的方案是将 Session 集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。常用的工具有 Redis，Memcached等。

采用第三方缓存来存储 Session 引起的一个问题是会引起网络访问。索然访问网络数据会涉及到握手、传输以及网络终端自身磁盘I/O等，但依然会选择高速缓存。

* Node 与缓存服务保持长连接，握手延迟只影响初始化
* 高速缓存直接在内存中进行数据存储和访问
* 缓存服务器通常与 Node 进程运行在相同的机器上或相同的机房，网络速度受到影响较小

**XSS漏洞**

XSS 全称是跨站脚本攻击(Cross Site Scripting)，XSS 漏洞会让别的脚本执行，主要形成原因多数是用户的输入没有被转义，而被直接执行。


#### 6. 缓存

为了提升性能，YSlow 中提到几条关于缓存的规则。

* 添加 Expires 或 Cache-Control 到报文头中
* 配置 ETags
* 让 Ajax 可缓存

通过来说，POST、DELETE、PUT 这类行为性的请求操作一般不做任何缓存、大多数缓存只应用在 GET请中。

**协商缓存**

* If-Modified-Since/Last-Modified
* If-None-Match/Etag

**强缓存**

* Expires(HTTP 1.0)
* Cache-Control: max-age

max-age 会覆盖 Expires。

**清除缓存**

* 每次发布，路径中跟随 Web 应用的版本号
* 每次帆布，路径中跟随文件内存的Hash值

### 数据上传

#### 1. 表单提交

默认的表单提交

```
Content-Type: application/x-www-form-urlencoded
foo=bar&baz=val
```

JSON类型

```
Content-Type: application/json
```

XML类型

```
Content-Type: application/xml
```
#### 2. 数据上传与安全

**内存限制**

在解析表单，JSON 和 XML 部分，我们采取的策略是先保存用户提交的所有数据，然后在解析处理，最后才传递给业务逻辑，这种策略存在的潜在问题是，它仅仅适合数据量小的提交请求，一旦数据量过大，将发生内存被占光的情况。

解决这个问题主要有两个方案。

* 限制上传内容的大小，一旦超过限制，停止接收数据，并响应 400 状态码
* 通过流式解析，将数据流导向到磁盘中，Node 只保留文件路径等小数据

**CSRF**

CSRF 的全称是 Cross-Site Request Forgery，中文意思为跨站请求伪造。通常而言，用户通过浏览器访问服务器端的 Session ID 是无法被第三方知道的，但是 CSRF 的攻击者并不需要知道 Session ID 就能让用户中招。

解决 CSRF 攻击的方案有添加随机值的方式。

为每个请求的用户，在 Sessoin 中赋予一个随机值，在做页面渲染的过程中，将这个随机值告诉前端。我们只需要在接收数据的时候做一次检验即可。

### 路由解析

如何根据 URL 做路由映射，这里有两个分支实现。一种是通过手工关联映射，一种是自然关联映射。前者会有一个对应的路由文件来将 URL 映射到对应的控制器，后者没有这样的文件。

#### 1. 手工映射

手工映射除了需要手工配置路由外较为原始外，它对 URL 的要求十分灵活。

手工映射的优点在于路径可以很灵活，但是如果项目较大，路由映射的数据会很多，从前端路径到具体的控制器文件，需要进行查阅才能定位到实际代码的位置。

#### 2. 自然映射

/controller/action/param1/param2/param3

#### RESTful

REST 全称是 Representational Status Transfer，中文含义为表现层状态转换。

### 中间件

中间件是指借助封装底层细节，为上层提供更方便服务。

#### 1. 异常处理

需要为 next() 方法添加 err 参数，并捕获中间件中间抛出的同步异常。

#### 2. 性能

* 编写高效的中间件
* 合理利用路由，避免不必要的中间执行

中间件使得前文的基础功能，从凌乱的发散状态收敛成很规整的组织方法。对于单个中间件而言，它足够简单，职责单一。

### 页面渲染

#### 模板

模板技术虽然多种多样，但它的实质就是将模板文件和数据通过模板引擎生成最终的HTML代码。形成模板技术的也就是下面四个要素。

* 模板语言
* 包含模板语言的模板文件
* 拥有动态数据的数据对象
* 模板引擎

**1. 模板引擎**

* 语法分解
* 处理表达式
* 生成待执行的语句
* 与数据一起执行，生成最终字符串

为了能够最终与数据一起执行生成字符串，我们需要将原始的模板字符串转换成一个函数对象，这个过程称为模板编译。生成的中间函数只与模板字符串相关，与具体的数据无关。

比如 hello <%=username%> 最终会生成如下代码。

```
function (obj) {
	var tpl = 'hello ' + obj.username + '';
	return tpl;
}	
```
预编译方法

```
var complie = function (str) {
	var tpl = str.replace(/<%=([\s\S]+?)%>/g, function(match, code) {
		return "' + obj." + code + " + '";
	});
	
	tpl = "var tpl = ' " + tpl + "'\n return tpl;";
	return new Function('obj, escape', tpl);
};

var render = function (complied, data) {
	return complied(data);
}
```
**2. 模板逻辑**

为了让模板变得更强大一点，我们为它添加逻辑代码，使得模板可以像 ASP、PHP 那样控制页面渲染。

**3. 集成文件系统**

与文件系统集成之后，引入缓存，可以很好地解决性能问题，接口得到大大的简化。

**4. 子模板**

子模板可以嵌套在别的模板中，多个模板可以嵌入同一个子模板中。维护多个子模板比维护完整而复杂的大模板的成本低很多。

实现子模板的诀窍就是先将 include 语句进行替换，再进行整体性能编译。

**5. 布局视图**

子模板的另一个使用方式是布局视图(layout)，布局视图又称母版页，它与子模板的原理相同，使用场景稍有区别。

**6. 模板性能**

* 缓存模板文件
* 缓存模板文件编译后的函数

#### Bigpipe

Bigpipe 主要是为了解决重数据页面的加载速度问题。解决思路是将页面分割多个部分，先向用户输出没有数据的布局，将每个部分逐个输出到前端，再最终渲染填充框架，完成整个网页的渲染。

Bigpipe 是一个需要前后端配合实现的优化技术。

* 页面布局框架(无数据)
* 后端持续性的数据输出
* 前端渲染

Bigpipe 将网页布局和数据渲染分离，使得用户在视觉上觉得网页提前渲染好，其随着数据输出的过程逐步渲染页面，使得用户能够感知到页面是活的。